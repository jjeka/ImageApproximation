#include <cstdio>
#include <cstring>
#include <cassert>
#include <cstdlib>
#include <cstdint>

#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))

class CFile
{
public:

	CFile(FILE* f_file):
		m_file(f_file)
	{
		if (!f_file)
			throw "Cannot open file";
	}
	
	CFile(const CFile& f_other) = delete;
	CFile(const CFile&& f_other) = delete;
	CFile operator =(const CFile& f_other) = delete;
	CFile operator =(const CFile&& f_other) = delete;

	operator FILE*()
	{
		return m_file;
	}

	~CFile()
	{
		fclose(m_file);
	}

private:

	FILE* m_file;
};

class CImage
{
public:

	CImage(const char* f_fileName);
	CImage(unsigned f_width, unsigned f_height);
	~CImage();

	void save(const char* f_fileName) const;

	CImage(const CImage& f_other);
	CImage(CImage&& f_other);

	CImage operator =(const CImage& f_other) = delete;
	CImage operator =(const CImage&& f_other) = delete;

	CImage thresholding(unsigned f_midValue);
	CImage randomDithering();
	CImage orderedDithering(unsigned m_numColorsExp2);
	CImage errorDiffusion(bool f_alternation);
	CImage floydSteinbergDithering(bool f_alternation);

private:

	unsigned char& at(unsigned f_x, unsigned f_y)
	{
		assert(f_x < m_width && f_y < m_height);
		return m_data[f_x + f_y * m_width];
	}
	unsigned char at(unsigned f_x, unsigned f_y) const
	{
		assert(f_x < m_width && f_y < m_height);
		return m_data[f_x + f_y * m_width];
	}

	unsigned m_width;
	unsigned m_height;

	unsigned char* m_data;

};

CImage::~CImage()
{
	delete[] m_data;
}

CImage::CImage(const char* f_filename)
{
	CFile file(fopen(f_filename, "r"));

	// PGM spec: No line should be longer than 70 characters
	// Use buffer with length 255 just in case
	char buf[255];

	if (fread(buf, 2, 1, file) != 1)
		throw "Cannot read file header";

	if (buf[0] != 'P' || buf[1] != '2')
		throw "File header is not P2";

	unsigned maxValue;
	
	while (fscanf(file, " #%[^\n]\n", buf)); // comment

	if (fscanf(file, " %u ", &m_width) != 1)
		throw "Can't read image width";
	
	while (fscanf(file, " #%[^\n]\n", buf)); // comment
	
	if (fscanf(file, " %u ", &m_height) != 1)
		throw "Can't read image height";
	
	while (fscanf(file, " #%[^\n]", buf)); // comment
	
	if (fscanf(file, " %u ", &maxValue) != 1)
		throw "Can't read image max value";
	
	if (!m_width || !m_height || !maxValue)
		throw "Invalid image dimensions or max value";

	if (maxValue != 255)
		throw "Max value is not 255. Convering image";

	m_data = new unsigned char[m_width * m_height];

	for (unsigned y = 0; y < m_height; y++)
	{
		for (unsigned x = 0; x < m_width; x++)
		{
			unsigned val;
			while (fscanf(file, " #%[^\n]\n", buf)); // comment
			if (fscanf(file, " %u ", &val) != 1)
			{
				delete m_data;
				throw "Can't read pixel value";
			}
			at(x, y) = val * 255 / maxValue;
		}
	}
}

CImage::CImage(unsigned f_width, unsigned f_height):
	m_width(f_width),
	m_height(f_height),
	m_data(new unsigned char[m_width * m_height])
{
	assert(f_width && f_height);

	memset(m_data, 0, m_width * m_height);
}

CImage::CImage(const CImage& f_other)
{
	m_width = f_other.m_width;
	m_height = f_other.m_height;
	m_data = new unsigned char[m_width * m_height];

	memcpy(m_data, f_other.m_data, m_width * m_height);
}

CImage::CImage(CImage&& f_other)
{
	m_width = f_other.m_width;
	m_height = f_other.m_height;
	m_data = f_other.m_data;

	f_other.m_data = nullptr;
}

void CImage::save(const char* f_fileName) const
{
	CFile file(fopen(f_fileName, "w"));

	fprintf(file, "P2\n# Autogenerated file\n%u %u\n255\n", m_width, m_height);

	unsigned lineLength = 0;
	for (unsigned y = 0; y < m_height; y++)
	{
		for (unsigned x = 0; x < m_width; x++)
		{
			if (lineLength > 55)
			{
				fprintf(file, "\n");
				lineLength = 0;
			}

			fprintf(file, "%u ", unsigned(at(x, y)));

			lineLength += 4;
		}
	}
}

CImage CImage::thresholding(unsigned f_midValue)
{
	CImage img(m_width, m_height);

	for (unsigned y = 0; y < m_height; y++)
	{
		for (unsigned x = 0; x < m_width; x++)
		{
			img.at(x, y) = (at(x, y) < f_midValue) ? 0 : 255;
		}
	}

	return img;
}

CImage CImage::randomDithering()
{
	CImage img(m_width, m_height);

	for (unsigned y = 0; y < m_height; y++)
	{
		for (unsigned x = 0; x < m_width; x++)
		{
			img.at(x, y) = (at(x, y) < rand() % 256) ? 0 : 255;
		}
	}

	return img;
}

unsigned short bitInterleaveReversed(unsigned char f_a, unsigned char f_b, unsigned f_size)
{
	unsigned short c = 0;
	for (unsigned i = 0; i < f_size; i++)
	{
       int a = (f_a & (1 << i)) != 0;
       int b = (f_b & (1 << i)) != 0;

		c |= a << (2 * f_size - (2 * i) - 1);
		c |= b << (2 * f_size - (2 * i + 1) - 1);
    }
	return c;
}

CImage CImage::orderedDithering(unsigned m_numColorsExp2)
{
	assert(m_numColorsExp2 && m_numColorsExp2 < 5);
	CImage img(m_width, m_height);
	
	unsigned size = 1 << m_numColorsExp2;
	unsigned char* mat = new unsigned char[size * size];
	for (unsigned x = 0; x < size; x++)
	{
		for (unsigned y = 0; y < size; y++)
		{
			// M(i, j) = bit_reverse(bit_interleave(bitwise_xor(i, j), i)) / n ^ 2
			mat[x + y * size] = (unsigned char) bitInterleaveReversed(x ^ y, y, m_numColorsExp2);
		}
	}

	for (unsigned y = 0; y < m_height; y++)
	{
		for (unsigned x = 0; x < m_width; x++)
		{
			img.at(x, y) = (at(x, y) < mat[x % size + (y % size) * size] * (256 / (size * size))) ? 0 : 255;
		}
	}

	delete[] mat;

	return img;
}

CImage CImage::errorDiffusion(bool f_alternation)
{
	CImage img(*this);

	for (unsigned y = 0; y < m_height; y++)
	{
		bool fromLeft = !f_alternation || y % 2 == 0;
		for (int x = (fromLeft ? 0 : m_width - 1); x >= 0 && x < int(m_width); fromLeft ? x++ : x--)
		{
			unsigned char val = img.at(x, y);
			bool isBlack = val < 128;
			img.at(x, y) = isBlack ? 0 : 255;

			if (!((fromLeft && x == m_width - 1) || (!fromLeft && x == 0)))
			{
				unsigned char& corVal = img.at(x + (fromLeft ? 1 : -1), y);
				if (isBlack)
					corVal = MIN(corVal + val, 255);
				else
					corVal = MAX(corVal - (255 - val), 0);
			}
		}
	}

	return img;
}

CImage CImage::floydSteinbergDithering(bool f_alternation)
{
	CImage img(*this);

	for (unsigned y = 0; y < m_height; y++)
	{
		bool fromLeft = !f_alternation || y % 2 == 0;
		for (int x = (fromLeft ? 0 : m_width - 1); x >= 0 && x < int(m_width); fromLeft ? x++ : x--)
		{
			unsigned char val = img.at(x, y);
			bool isBlack = val < 128;
			img.at(x, y) = isBlack ? 0 : 255;
			int correction = isBlack ? val : -(255 - val);

			auto correct = [this, x, y, correction, fromLeft, &img](int dx, int dy, int coef)
			{
				int xc = x + (fromLeft ? dx : -dx);
				int yc = y + dy;
				if (xc >= 0 && xc < int(m_width) && yc >= 0 && yc < int(m_height))
				{
					img.at(xc, yc) = MAX(0, MIN(int(img.at(xc, yc)) + correction * coef / 16, 255));
				}
			};
			
			correct( 1, 0, 16);
			correct(-1, 1, 3);
			correct( 0, 1, 5);
			correct( 1, 1, 1);
		}
	}

	return img;
}

void printUsage(const char* f_name)
{
	printf("Usage:\n"
		"%s src_pgm_file dst_pgm_file conversion_type [options]\n"
		"conversion type and options:\n"
		"thresholding middle_value (from 0 to 255)\n"
		"random_dithering\n"
		"ordered_dithreing map_size (2,4,8,16,32)\n"
		"error_diffusion alternation (0/1)\n"
		"floyd_steinberg_dithering alternation (0/1)\n", f_name);
}

int main(int f_argc, const char* f_argv[])
{
	if (f_argc != 4 && f_argc != 5)
	{
		printUsage(f_argv[0]);
		return 1;
	}

	try
	{
		CImage img(f_argv[1]);
		const char* dst = f_argv[2];
		const char* type = f_argv[3];
		const char* arg = f_argv[4];

		if (!strcmp(type, "thresholding"))
		{
			unsigned val;
			if (f_argc != 5 || sscanf(arg, " %u ", &val) != 1 || val > 255)
			{
				printUsage(f_argv[0]);
				return 1;
			}
			img.thresholding(val).save(dst);
		}
		else if (!strcmp(type, "random_dithering"))
		{
			if (f_argc != 4)
			{
				printUsage(f_argv[0]);
				return 1;
			}
			img.randomDithering().save(dst);
		}
		else if (!strcmp(type, "ordered_dithreing"))
		{
			unsigned val;
			if (f_argc != 5 || sscanf(arg, " %u ", &val) != 1
				|| (val != 2 && val != 4 && val != 8 && val != 16 && val != 32))
			{
				printUsage(f_argv[0]);
				return 1;
			}
			if (val == 2)
				val = 1;
			else if (val == 4)
				val = 2;
			else if (val == 8)
				val = 3;
			else if (val == 16)
				val = 4;
			else
				val = 5;

			img.orderedDithering(val).save(dst);
		}
		else if (!strcmp(type, "error_diffusion"))
		{
			unsigned val;
			if (f_argc != 5 || sscanf(arg, " %u ", &val) != 1 || val > 1)
			{
				printUsage(f_argv[0]);
				return 1;
			}
			img.errorDiffusion(val).save(dst);
		}
		else if (!strcmp(type, "floyd_steinberg_dithering"))
		{
			unsigned val;
			if (f_argc != 5 || sscanf(arg, " %u ", &val) != 1 || val > 1)
			{
				printUsage(f_argv[0]);
				return 1;
			}
			img.floydSteinbergDithering(val).save(dst);
		}
		else
		{
			printUsage(f_argv[0]);
			return 1;
		}
	}
	catch (const char* f_error)
	{
		printf("ERROR: %s", f_error);
		return 1;
	}
	return 0;
}